}
if(length(ord.cors) == 1){
lambda.max[i] <- ord.cors
}
}
}
if(gamma == 0){
lambda.max <- abs(t(X) %*% resp)
}
if(gamma == 1){
for(i in 1:num.groups){
if (i<num.groups) {
cors <- t(X[i:n,]) %*% resp[i:n] * 2/n}
else {
cors <- t(X[i:n,] %*% t(resp[i:n]))*2/n
}
lambda.max[i] <- sqrt(sum(cors^2))
}
}
max.lam <- max(lambda.max)
min.lam <- min.frac*max.lam
lambdas <- exp(seq(log(max.lam),log(min.lam), (log(min.lam) - log(max.lam))/(nlam-1)))
return(lambdas)
}
lambdas <- PathCalc(data = data, gamma=gamma, min.frac = min.frac, nlam = nlam)
lambdas
library(ChangePointCalc)
clear
library(ChangePointCalc)
ChangePoints <- c(101,201)
n <- 300
p <- 200
s <- 10
SData <- SynthesizeData(ChangePoints, sigma1=1, sigma2=0.1, n, p, s,coefficients=NULL)
View(coefficients)
View(SData$coefficients)
resultSGL <- SGLmain(data=SData,gamma=0.90)
library(ChangePointCalc)
ChangePoints <- c(101,201)
n <- 300
p <- 200
s <- 10
SData <- SynthesizeData(ChangePoints, sigma1=1, sigma2=0.1, n, p, s,coefficients=NULL)
resultSGL <- SGLmain(data=SData,gamma=0.90)
SGLPlotChangePoint(resultSGL, n, p, num=20, breaks=NULL)
SGLPlotChangePoint(resultSGL, n, p, num=10, breaks=NULL)
SGLPlotChangePoint(resultSGL, n, p, num=1, breaks=NULL)
SGLPlotChangePoint(resultSGL, n, p, num=2, breaks=NULL)
SGLPlotChangePoint(resultSGL, n, p, num=3, breaks=NULL)
SGLPlotChangePoint(resultSGL, n, p, num=4, breaks=NULL)
SGLPlotChangePoint(resultSGL, n, p, num=5, breaks=NULL)
SGLPlotChangePoint(resultSGL, n, p, num=6, breaks=NULL)
SGLPlotChangePoint(resultSGL, n, p, num=7, breaks=NULL)
SGLPlotChangePoint(resultSGL, n, p, num=7, breaks=NULL)
SGLPlotChangePoint(resultSGL, n, p, num=6, breaks=NULL)
SGLPlotNorm(resultSGL, n, p, num=10, breaks=NULL,norm=2)
SGLPlotNorm <- function(fit, n, p, num=1, breaks=NULL,norm=2)
{
# this function plot the l1 norm of theta in the result
# num is the num th lambda we used
# n is the number of data sample
# p is the number of dimension
#norm=2 is l2 norm, norm=1 is l1 norm
#breaks is the break tick the user want to show on the plot,
#if breaks is NULL the default setting is to divide x-axis into 10 equal segment and label the
#tick accordingly
t_sum = matrix(NA, n, 1)
if(norm==1)
{
for (i in 1:n)
{ t_sum[i] = sum(abs(fit$beta[((i-1)*p+1):(i*p), num]))}
}
if(norm==2)
{
for (i in 1:n)
{ t_sum[i] = sqrt(sum((fit$beta[((i-1)*p+1):(i*p), num])^2))}
}
plotData <- data.frame(pos=1:length(t_sum), normL1=t_sum)
plotTsum <- ggplot(plotData, aes(pos, normL1))
{
if(is.null(breaks))
{
plotTsum + geom_point() + theme_bw(base_size=16) + xlab("Number of Observations") + ylab(expression(paste(group("|",group("|", theta[i], "|"),"|"))[1]))+scale_x_continuous(breaks=seq(1, n, floor(n/10)))
}
else
{
plotTsum + geom_point() + theme_bw(base_size=16) + xlab("Number of Observations") + ylab(expression(paste(group("|",group("|", theta[i], "|"),"|"))[1]))+scale_x_continuous(breaks=breaks)
}
}
#plotTsum + geom_point() + theme_bw(base_size=16) + xlab("Number of Observations") + ylab(expression(paste(group("|",group("|", theta[i], "|"),"|"))[1]))+scale_x_continuous(breaks=seq(1, n, floor(n/10)))
}
SGLPlotNorm(resultSGL, n, p, num=10, breaks=NULL,norm=2)
SGLPlotNorm(resultSGL, n, p, num=10, breaks=NULL,norm=1)
SGLPlotNorm <- function(fit, n, p, num=1, breaks=NULL,norm=2)
{
# this function plot the l1 norm of theta in the result
# num is the num th lambda we used
# n is the number of data sample
# p is the number of dimension
#norm=2 is l2 norm, norm=1 is l1 norm
#breaks is the break tick the user want to show on the plot,
#if breaks is NULL the default setting is to divide x-axis into 10 equal segment and label the
#tick accordingly
t_sum = matrix(NA, n, 1)
if(norm==1)
{
for (i in 1:n)
{ t_sum[i] = sum(abs(fit$beta[((i-1)*p+1):(i*p), num]*fit$X.transform))}
}
if(norm==2)
{
for (i in 1:n)
{ t_sum[i] = sqrt(sum((fit$beta[((i-1)*p+1):(i*p), num]*fit$X.transform)^2))}
}
plotData <- data.frame(pos=1:length(t_sum), normL1=t_sum)
plotTsum <- ggplot(plotData, aes(pos, normL1))
{
if(is.null(breaks))
{
plotTsum + geom_point() + theme_bw(base_size=16) + xlab("Number of Observations") + ylab(expression(paste(group("|",group("|", theta[i], "|"),"|"))[1]))+scale_x_continuous(breaks=seq(1, n, floor(n/10)))
}
else
{
plotTsum + geom_point() + theme_bw(base_size=16) + xlab("Number of Observations") + ylab(expression(paste(group("|",group("|", theta[i], "|"),"|"))[1]))+scale_x_continuous(breaks=breaks)
}
}
#plotTsum + geom_point() + theme_bw(base_size=16) + xlab("Number of Observations") + ylab(expression(paste(group("|",group("|", theta[i], "|"),"|"))[1]))+scale_x_continuous(breaks=seq(1, n, floor(n/10)))
}
SGLPlotNorm(resultSGL, n, p, num=10, breaks=NULL,norm=1)
SGLPlotNorm(resultSGL, n, p, num=10, breaks=NULL,norm=2)
SGLPlotNorm(resultSGL, n, p, num=10, breaks=NULL,norm=1)
SGLPlotNorm(resultSGL, n, p, num=5, breaks=NULL,norm=1)
SGLPlotNorm(resultSGL, n, p, num=6, breaks=NULL,norm=1)
SGLPlotNorm(resultSGL, n, p, num=7, breaks=NULL,norm=1)
SGLPlotNorm(resultSGL, n, p, num=8, breaks=NULL,norm=1)
SGLPlotNorm <- function(fit, n, p, num=1, breaks=NULL,norm=2)
{
# this function plot the l1 norm of theta in the result
# num is the num th lambda we used
# n is the number of data sample
# p is the number of dimension
#norm=2 is l2 norm, norm=1 is l1 norm
#breaks is the break tick the user want to show on the plot,
#if breaks is NULL the default setting is to divide x-axis into 10 equal segment and label the
#tick accordingly
t_sum = matrix(NA, n, 1)
if(norm==1)
{
for (i in 1:n)
{ t_sum[i] = sum(abs(fit$beta[((i-1)*p+1):(i*p), num]*fit$X.transform))}
}
if(norm==2)
{
for (i in 1:n)
{ t_sum[i] = sqrt(sum((fit$beta[((i-1)*p+1):(i*p), num]*fit$X.transform)^2))}
}
plotData <- data.frame(pos=1:length(t_sum), normL1=t_sum)
plotTsum <- ggplot(plotData, aes(pos, normL1))
if (norm==1)
{
if(is.null(breaks))
{
plotTsum + geom_point() + theme_bw(base_size=16) + xlab("Number of Observations") + ylab(expression(paste(group("|",group("|", theta[i], "|"),"|"))[1]))+scale_x_continuous(breaks=seq(1, n, floor(n/10)))
}
else
{
plotTsum + geom_point() + theme_bw(base_size=16) + xlab("Number of Observations") + ylab(expression(paste(group("|",group("|", theta[i], "|"),"|"))[1]))+scale_x_continuous(breaks=breaks)
}
}
if (norm==2)
{
if(is.null(breaks))
{
plotTsum + geom_point() + theme_bw(base_size=16) + xlab("Number of Observations") + ylab(expression(paste(group("|",group("|", theta[i], "|"),"|"))[2]))+scale_x_continuous(breaks=seq(1, n, floor(n/10)))
}
else
{
plotTsum + geom_point() + theme_bw(base_size=16) + xlab("Number of Observations") + ylab(expression(paste(group("|",group("|", theta[i], "|"),"|"))[2]))+scale_x_continuous(breaks=breaks)
}
}
#plotTsum + geom_point() + theme_bw(base_size=16) + xlab("Number of Observations") + ylab(expression(paste(group("|",group("|", theta[i], "|"),"|"))[1]))+scale_x_continuous(breaks=seq(1, n, floor(n/10)))
}
SGLPlotNorm(resultSGL, n, p, num=8, breaks=NULL,norm=2)
SGLPlotChangePoint <- function(fit, n, p, num=1, breaks=NULL)
{
# this function plot the l1 norm of theta in the result
# num is the num th lambda we used
# n is the number of data sample
# p is the number of dimension
#breaks is the break tick the user want to show on the plot,
#if breaks is NULL the default setting is to divide x-axis into 10 equal segment and label the
#tick accordingly
t_sum = mat.or.vec(n, 1)
for (i in 1:n)
{
if (sum(abs(fit$beta[((i-1)*p+1):(i*p),num]))>0)
{
t_sum[i]<-1
}
}
plotData <- data.frame(pos=1:length(t_sum), normL1=t_sum)
plotTsum <- ggplot(plotData, aes(pos, normL1))
{
if(is.null(breaks))
{
plotTsum + geom_point() + theme_bw(base_size=16) + xlab("Number of Observations") + ylab("Change-point")+scale_x_continuous(breaks=seq(1, n, floor(n/10)))+scale_y_continuous(breaks=c(0,1))
}
else
{
plotTsum + geom_point() + theme_bw(base_size=16) + xlab("Number of Observations") + ylab("Change-point")+scale_x_continuous(breaks=breaks)+scale_y_continuous(breaks=c(0,1))
}
}
retrun(t_sum)
}
SGLPlotNorm(resultSGL, n, p, num=8, breaks=NULL,norm=2)
t_sum <- SGLPlotNorm(resultSGL, n, p, num=8, breaks=NULL,norm=2)
SGLPlotNorm <- function(fit, n, p, num=1, breaks=NULL,norm=2)
{
# this function plot the l1 norm of theta in the result
# num is the num th lambda we used
# n is the number of data sample
# p is the number of dimension
#norm=2 is l2 norm, norm=1 is l1 norm
#breaks is the break tick the user want to show on the plot,
#if breaks is NULL the default setting is to divide x-axis into 10 equal segment and label the
#tick accordingly
t_sum = matrix(NA, n, 1)
if(norm==1)
{
for (i in 1:n)
{ t_sum[i] = sum(abs(fit$beta[((i-1)*p+1):(i*p), num]*fit$X.transform))}
}
if(norm==2)
{
for (i in 1:n)
{ t_sum[i] = sqrt(sum((fit$beta[((i-1)*p+1):(i*p), num]*fit$X.transform)^2))}
}
plotData <- data.frame(pos=1:length(t_sum), normL1=t_sum)
plotTsum <- ggplot(plotData, aes(pos, normL1))
if (norm==1)
{
if(is.null(breaks))
{
plotTsum + geom_point() + theme_bw(base_size=16) + xlab("Number of Observations") + ylab(expression(paste(group("|",group("|", theta[i], "|"),"|"))[1]))+scale_x_continuous(breaks=seq(1, n, floor(n/10)))
}
else
{
plotTsum + geom_point() + theme_bw(base_size=16) + xlab("Number of Observations") + ylab(expression(paste(group("|",group("|", theta[i], "|"),"|"))[1]))+scale_x_continuous(breaks=breaks)
}
}
if (norm==2)
{
if(is.null(breaks))
{
plotTsum + geom_point() + theme_bw(base_size=16) + xlab("Number of Observations") + ylab(expression(paste(group("|",group("|", theta[i], "|"),"|"))[2]))+scale_x_continuous(breaks=seq(1, n, floor(n/10)))
}
else
{
plotTsum + geom_point() + theme_bw(base_size=16) + xlab("Number of Observations") + ylab(expression(paste(group("|",group("|", theta[i], "|"),"|"))[2]))+scale_x_continuous(breaks=breaks)
}
}
#plotTsum + geom_point() + theme_bw(base_size=16) + xlab("Number of Observations") + ylab(expression(paste(group("|",group("|", theta[i], "|"),"|"))[1]))+scale_x_continuous(breaks=seq(1, n, floor(n/10)))
return(t_sum)
}
t_sum <- SGLPlotNorm(resultSGL, n, p, num=8, breaks=NULL,norm=2)
View(t_sum)
sqrt(160)
library(ChangePointCalc)
library(ChangePointCalc)
log(2)
log(3)
a=log(80000)/400
a
10*sqrt(a)
ChangePoints <- c(101,201)
n <- 400
p <- 200
s <- 10
SData <- SynthesizeData(ChangePoints, sigma1=1, sigma2=0.1, n, p, s,coefficients=NULL)
resultSGL <- SGLmain(data=SData,gamma=0.90)
SGLPlotChangePoint(resultSGL, n, p, num=20, breaks=NULL)
SGLPlotNorm(resultSGL, n, p, num=10, breaks=NULL,norm=2)
SGLPlotNorm(resultSGL, n, p, num=20, breaks=NULL,norm=2)
SGLPlotNorm(resultSGL, n, p, num=20, breaks=NULL,norm=2)
SGLPlotNorm(resultSGL, n, p, num=1, breaks=NULL,norm=2)
SGLPlotChangePoint(resultSGL, n, p, num=20, breaks=NULL)
SGLPlotNorm(resultSGL, n, p, num=20, breaks=NULL,norm=2)
SGLPlotNorm <- function(fit, n, p, num=1, breaks=NULL,norm=2)
{
# this function plot the l1 norm of theta in the result
# num is the num th lambda we used
# n is the number of data sample
# p is the number of dimension
#norm=2 is l2 norm, norm=1 is l1 norm
#breaks is the break tick the user want to show on the plot,
#if breaks is NULL the default setting is to divide x-axis into 10 equal segment and label the
#tick accordingly
t_sum = matrix(NA, n, 1)
if(norm==1)
{
for (i in 1:n)
{ t_sum[i] = sum(abs(fit$beta[((i-1)*p+1):(i*p), num]*fit$X.transform))}
}
if(norm==2)
{
for (i in 1:n)
{ t_sum[i] = sqrt(sum((fit$beta[((i-1)*p+1):(i*p), num]*fit$X.transform)^2))}
}
plotData <- data.frame(pos=1:length(t_sum), normL1=t_sum)
plotTsum <- ggplot(plotData, aes(pos, normL1))
if (norm==1)
{
if(is.null(breaks))
{
plotTsum + geom_point() + theme_bw(base_size=16) + xlab("Number of Observations") + ylab(expression(paste(group("|",group("|", theta[i], "|"),"|"))[1]))+scale_x_continuous(breaks=seq(1, n, floor(n/10)))
}
else
{
plotTsum + geom_point() + theme_bw(base_size=16) + xlab("Number of Observations") + ylab(expression(paste(group("|",group("|", theta[i], "|"),"|"))[1]))+scale_x_continuous(breaks=breaks)
}
}
if (norm==2)
{
if(is.null(breaks))
{
plotTsum + geom_point() + theme_bw(base_size=16) + xlab("Number of Observations") + ylab(expression(paste(group("|",group("|", theta[i], "|"),"|"))[2]))+scale_x_continuous(breaks=seq(1, n, floor(n/10)))
}
else
{
plotTsum + geom_point() + theme_bw(base_size=16) + xlab("Number of Observations") + ylab(expression(paste(group("|",group("|", theta[i], "|"),"|"))[2]))+scale_x_continuous(breaks=breaks)
}
}
#plotTsum + geom_point() + theme_bw(base_size=16) + xlab("Number of Observations") + ylab(expression(paste(group("|",group("|", theta[i], "|"),"|"))[1]))+scale_x_continuous(breaks=seq(1, n, floor(n/10)))
return(t_sum)
}
SGLPlotNorm(resultSGL, n, p, num=20, breaks=NULL,norm=2)
SGLPlotNorm <- function(fit, n, p, num=1, breaks=NULL,norm=2)
{
# this function plot the l1 norm of theta in the result
# num is the num th lambda we used
# n is the number of data sample
# p is the number of dimension
#norm=2 is l2 norm, norm=1 is l1 norm
#breaks is the break tick the user want to show on the plot,
#if breaks is NULL the default setting is to divide x-axis into 10 equal segment and label the
#tick accordingly
t_sum = matrix(NA, n, 1)
if(norm==1)
{
for (i in 1:n)
{ t_sum[i] = sum(abs(fit$beta[((i-1)*p+1):(i*p), num]*fit$X.transform))}
}
if(norm==2)
{
for (i in 1:n)
{ t_sum[i] = sqrt(sum((fit$beta[((i-1)*p+1):(i*p), num]*fit$X.transform)^2))}
}
plotData <- data.frame(pos=1:length(t_sum), normL1=t_sum)
plotTsum <- ggplot(plotData, aes(pos, normL1))
if (norm==1)
{
if(is.null(breaks))
{
plotTsum + geom_point() + theme_bw(base_size=16) + xlab("Number of Observations") + ylab(expression(paste(group("|",group("|", theta[i], "|"),"|"))[1]))+scale_x_continuous(breaks=seq(1, n, floor(n/10)))
}
else
{
plotTsum + geom_point() + theme_bw(base_size=16) + xlab("Number of Observations") + ylab(expression(paste(group("|",group("|", theta[i], "|"),"|"))[1]))+scale_x_continuous(breaks=breaks)
}
}
if (norm==2)
{
if(is.null(breaks))
{
plotTsum + geom_point() + theme_bw(base_size=16) + xlab("Number of Observations") + ylab(expression(paste(group("|",group("|", theta[i], "|"),"|"))[2]))+scale_x_continuous(breaks=seq(1, n, floor(n/10)))
}
else
{
plotTsum + geom_point() + theme_bw(base_size=16) + xlab("Number of Observations") + ylab(expression(paste(group("|",group("|", theta[i], "|"),"|"))[2]))+scale_x_continuous(breaks=breaks)
}
}
#plotTsum + geom_point() + theme_bw(base_size=16) + xlab("Number of Observations") + ylab(expression(paste(group("|",group("|", theta[i], "|"),"|"))[1]))+scale_x_continuous(breaks=seq(1, n, floor(n/10)))
}
SGLPlotNorm(resultSGL, n, p, num=20, breaks=NULL,norm=2)
library(ChangePointCalc)
library(ChangePointCalc)
ChangePoints <- c(101,301)
n <- 600
p <- 300
s <- 10
SData <- SynthesizeData(ChangePoints, sigma1=1, sigma2=0.1, n, p, s,coefficients=NULL)
resultSGL <- SGLmain(data=SData,gamma=0.90)
SGLPlotChangePoint(resultSGL, n, p, num=20, breaks=NULL)
SGLPlotNorm(resultSGL, n, p, num=20, breaks=NULL,norm=2)
library(ChangePointCalc)
ChangePoints <- c(101,301,701)
n <- 800
p <- 200
s <- 10
SData <- SynthesizeData(ChangePoints, sigma1=1, sigma2=0.1, n, p, s,coefficients=NULL)
resultSGL <- SGLmain(data=SData,gamma=0.90)
SGLPlotChangePoint(resultSGL, n, p, num=20, breaks=NULL)
SGLPlotNorm(resultSGL, n, p, num=20, breaks=NULL,norm=2)
SGLPlotNorm(resultSGL, n, p, num=20, breaks=1:100:801,norm=2)
1:100:801
seq(1,801, by=100
)
SGLPlotNorm(resultSGL, n, p, num=20, breaks=seq(1,801, by=100),norm=2)
save.image("C:/Users/bzhang/Dropbox/SGL program/PackageTest_11_26_2014/ChangePointCalc/high_SGL_04282015.RData")
SGLPlotChangePoint(resultSGL, n, p, num=20, breaks=seq(1,801, by=100),norm=2)
SGLPlotChangePoint(resultSGL, n, p, num=20, breaks=seq(1,801, by=100))
load(ChangePointCalc)
SGLPlotChangePoint(resultSGL, n, p, num=20, breaks=NULL)
resultSGL$lambdas
library(ChangePointCalc)
load("F:/Dropbox/SGL program/PackageTest_11_26_2014/ChangePointCalc/high_SGL_04282015.RData")
n <- 800
p <- 200
s <- 10
SGLPlotChangePoint(resultSGL, n, p, num=20, breaks=NULL)
SGLPlotChangePoint(resultSGL, n, p, num=19, breaks=NULL)
SGLPlotChangePoint(resultSGL, n, p, num=18, breaks=NULL)
SGLPlotChangePoint(resultSGL, n, p, num=17, breaks=NULL)
SGLPlotChangePoint(resultSGL, n, p, num=17, breaks=NULL)
SGLPlotChangePoint(resultSGL, n, p, num=16, breaks=NULL)
SGLPlotChangePoint(resultSGL, n, p, num=16, breaks=NULL)
SGLPlotChangePoint(resultSGL, n, p, num=15, breaks=NULL)
SGLPlotChangePoint(resultSGL, n, p, num=14, breaks=NULL)
SGLPlotChangePoint(resultSGL, n, p, num=13, breaks=NULL)
SGLPlotChangePoint(resultSGL, n, p, num=13, breaks=NULL)
SGLPlotChangePoint(resultSGL, n, p, num=12, breaks=NULL)
SGLPlotChangePoint(resultSGL, n, p, num=11, breaks=NULL)
SGLPlotChangePoint(resultSGL, n, p, num=20, breaks=NULL)
SGLPlotChangePoint(resultSGL, n, p, num=19, breaks=NULL)
lambdas
resultSGL$lambdas
SGLPlotNorm(resultSGL, n, p, num=20, breaks=NULL,norm=2)
resultSGL$beta[1]
a<-matrix(resultSGL$beta[,20],nrow=800,ncol=200)
resultSGL$beta[1,20]
resultSGL$beta[2,20]
View(a)
lamdas
resultSGL$lambdas
a<-matrix(resultSGL$beta[,18],nrow=800,ncol=200)
View(a)
b=sum(a)
b=sum(a,2)
colSums(a)
a[1,]
a[101,]
a[2,]
a[3,]
a[301,]
a[701,]
ChangePoints <- c(101,301,701)
n <- 800
p <- 20
s <- 10
SData <- SynthesizeData(ChangePoints, sigma1=1, sigma2=0.1, n, p, s,coefficients=NULL)
resultSGL <- SGLmain(data=SData,gamma=0.90)
library(ChangePointCalc)
ChangePoints <- c(101,301,701)
n <- 800
p <- 20
s <- 10
SData <- SynthesizeData(ChangePoints, sigma1=1, sigma2=0.1, n, p, s,coefficients=NULL)
resultSGL <- SGLmain(data=SData,gamma=0.90)
SGLPlotChangePoint(resultSGL, n, p, num=20, breaks=NULL)
ChangePoints <- c(101,301,701)
n <- 800
p <- 200
s <- 10
SData <- SynthesizeDataLogistic(ChangePoints, sigma1=1, sigma2=0.1, n, p, s,coefficients=NULL)
install.packages("Rtools")
library(ChangePointCalc)
ChangePoints <- c(101,301,701)
n <- 800
p <- 200
s <- 10
SData <- SynthesizeDataLogistic(ChangePoints, sigma1=1, sigma2=0.1, n, p, s,coefficients=NULL)
library(ChangePointCalc)
SData <- SynthesizeDataLogistic(ChangePoints, sigma1=1, sigma2=0.1, n, p, s,coefficients=NULL)
library(ChangePointCalc)
ChangePoints <- c(101,301,701)
n <- 800
#ChangePoints = c(11)
#n = 20
p <- 200
s <- 10
SData <- SynthesizeDataLogistic(ChangePoints, sigma1=1, sigma2=0.1, n, p, s,coefficients=NULL)
resultSGL <- SGLLogitmain(data=SData,gamma=0.90)
SGLPlotChangePoint(resultSGL, n, p, num=20, breaks=NULL)
SGLPlotNorm(resultSGL, n, p, num=16, breaks=NULL,norm=2)
SGLPlotNorm(resultSGL, n, p, num=12, breaks=NULL,norm=2)
SGLPlotNorm(resultSGL, n, p, num=10, breaks=NULL,norm=2)
SGLPlotNorm(resultSGL, n, p, num=10, breaks=c(101,201,301,401,501,601,701),norm=2)
SGLPlotNorm(resultSGL, n, p, num=1, breaks=c(101,201,301,401,501,601,701),norm=2)
SGLPlotNorm(resultSGL, n, p, num=2, breaks=c(101,201,301,401,501,601,701),norm=2)
SGLPlotNorm(resultSGL, n, p, num=4, breaks=c(101,201,301,401,501,601,701),norm=2)
SGLPlotNorm(resultSGL, n, p, num=6, breaks=c(101,201,301,401,501,601,701),norm=2)
SGLPlotNorm(resultSGL, n, p, num=8, breaks=c(101,201,301,401,501,601,701),norm=2)
SGLPlotNorm(resultSGL, n, p, num=9, breaks=c(101,201,301,401,501,601,701),norm=2)
SGLPlotNorm(resultSGL, n, p, num=8, breaks=c(101,201,301,401,501,601,701),norm=2)
SGLPlotNorm(resultSGL, n, p, num=9, breaks=c(101,201,301,401,501,601,701),norm=2)
SGLPlotNorm(resultSGL, n, p, num=8, breaks=c(101,201,301,401,501,601,701),norm=2)
SGLPlotChangePoint(resultSGL, n, p, num=8, breaks=NULL)
SGLPlotChangePoint(resultSGL, n, p, num=8, breaks=c(1,101,201,301,401,501,601,701,801))
SGLPlotChangePoint(resultSGL, n, p, num=8, breaks=c(1,101,201,301,401,501,601,701,801))
SGLPlotNorm(resultSGL, n, p, num=8, breaks=c(1,101,201,301,401,501,601,701,801),norm=2)
resultSGL$lambdas[8]
9+18+2.59+10.8

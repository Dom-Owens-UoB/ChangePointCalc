if(norms[length(ord.cors)-1] <= lam[length(ord.cors)] * gamma){
our.cors <- ord.cors
our.range <- c(0, ord.cors[length(ord.cors)])/(1-gamma)
} else{
my.ind <- max(which(norms[-length(norms)] <= lam[2:(length(norms))] * gamma)) + 1
our.cors <- ord.cors[1:my.ind]
our.range <- c(ord.cors[my.ind+1], ord.cors[my.ind])/(1-gamma)
}
}
nn <- length(our.cors)
if(gamma == 0.5){
gamma = 0.500001
}
A.term <- nn*(1-gamma)^2 - gamma^2
B.term <- - 2 * (1-gamma) * sum(our.cors)
C.term <- sum(our.cors^2)
lams <- c((-B.term + sqrt(B.term^2 - 4 * A.term * C.term))/(2*A.term), (-B.term - sqrt(B.term^2 - 4 * A.term * C.term))/(2*A.term))
if((lams[1] >= our.range[1] && lams[1] <= our.range[2]) || (lams[2] >= our.range[1] && lams[2] <= our.range[2])) {
lambda.max[i] <- min(subset(lams, lams >= our.range[1] & lams <= our.range[2]))
}
else {
lambda.max[i] = our.range[1]
}
}
if(length(ord.cors) == 1){
lambda.max[i] <- ord.cors
}
}
}
if(gamma == 0){
lambda.max <- abs(t(X) %*% resp)
}
if(gamma == 1){
for(i in 1:num.groups){
if (i<num.groups) {
cors <- t(X[i:n,]) %*% resp[i:n] * 2/n}
else {
cors <- t(X[i:n,] %*% t(resp[i:n]))*2/n
}
lambda.max[i] <- sqrt(sum(cors^2))
}
}
max.lam <- max(lambda.max)
min.lam <- min.frac*max.lam
print(max.lam)
print(min.lam)
lambdas <- exp(seq(log(max.lam),log(min.lam), (log(min.lam) - log(max.lam))/(nlam-1)))
return(lambdas)
}
lambdas <- PathCalc(data = data, gamma=gamma, min.frac = min.frac, nlam = nlam)
PathCalc <- function(data, gamma = 0.90, min.frac = 0.05, nlam = 20){
X <- data$x
resp <- data$y
n <- nrow(X)
p <- ncol(X)
np <- n*p
num.groups <- n
lambda.max <- rep(0,num.groups)
if((gamma != 0)*(gamma != 1)){
for(i in 1:num.groups){
if(i<num.groups)
{
cors <- t(X[i:n,]) %*% resp[i:n]*2/n
}
else {
cors <- t(X[i:n,] %*% t(resp[i:n]))*2/n
}
ord.cors <- sort(abs(cors), decreasing = TRUE)
if(length(ord.cors) > 1){
norms <- rep(0,length(cors)-1)
lam <- ord.cors/(1-gamma)
for(j in 1:(length(ord.cors)-1)){
norms[j] <- sqrt(sum((ord.cors[1:j]-ord.cors[j+1])^2))
}
if(norms[1] >= lam[2] * gamma){
our.cors <- ord.cors[1]
our.range <- c(ord.cors[2], ord.cors[1])/(1-gamma)
}else{
if(norms[length(ord.cors)-1] <= lam[length(ord.cors)] * gamma){
our.cors <- ord.cors
our.range <- c(0, ord.cors[length(ord.cors)])/(1-gamma)
} else{
my.ind <- max(which(norms[-length(norms)] <= lam[2:(length(norms))] * gamma)) + 1
our.cors <- ord.cors[1:my.ind]
our.range <- c(ord.cors[my.ind+1], ord.cors[my.ind])/(1-gamma)
}
}
nn <- length(our.cors)
if(gamma == 0.5){
gamma = 0.500001
}
A.term <- nn*(1-gamma)^2 - gamma^2
B.term <- - 2 * (1-gamma) * sum(our.cors)
C.term <- sum(our.cors^2)
lams <- c((-B.term + sqrt(B.term^2 - 4 * A.term * C.term))/(2*A.term), (-B.term - sqrt(B.term^2 - 4 * A.term * C.term))/(2*A.term))
if((lams[1] >= our.range[1] && lams[1] <= our.range[2]) || (lams[2] >= our.range[1] && lams[2] <= our.range[2])) {
lambda.max[i] <- min(subset(lams, lams >= our.range[1] & lams <= our.range[2]))
}
else {
lambda.max[i] = our.range[1]
}
}
if(length(ord.cors) == 1){
lambda.max[i] <- ord.cors
}
}
}
if(gamma == 0){
lambda.max <- abs(t(X) %*% resp)
}
if(gamma == 1){
for(i in 1:num.groups){
if (i<num.groups) {
cors <- t(X[i:n,]) %*% resp[i:n] * 2/n}
else {
cors <- t(X[i:n,] %*% t(resp[i:n]))*2/n
}
lambda.max[i] <- sqrt(sum(cors^2))
}
}
max.lam <- max(lambda.max)
min.lam <- min.frac*max.lam
lambdas <- exp(seq(log(max.lam),log(min.lam), (log(min.lam) - log(max.lam))/(nlam-1)))
return(lambdas)
}
lambdas <- PathCalc(data = data, gamma=gamma, min.frac = min.frac, nlam = nlam)
lambdas
library(ChangePointCalc)
clear
library(ChangePointCalc)
ChangePoints <- c(101,201)
n <- 300
p <- 200
s <- 10
SData <- SynthesizeData(ChangePoints, sigma1=1, sigma2=0.1, n, p, s,coefficients=NULL)
View(coefficients)
View(SData$coefficients)
resultSGL <- SGLmain(data=SData,gamma=0.90)
library(ChangePointCalc)
ChangePoints <- c(101,201)
n <- 300
p <- 200
s <- 10
SData <- SynthesizeData(ChangePoints, sigma1=1, sigma2=0.1, n, p, s,coefficients=NULL)
resultSGL <- SGLmain(data=SData,gamma=0.90)
SGLPlotChangePoint(resultSGL, n, p, num=20, breaks=NULL)
SGLPlotChangePoint(resultSGL, n, p, num=10, breaks=NULL)
SGLPlotChangePoint(resultSGL, n, p, num=1, breaks=NULL)
SGLPlotChangePoint(resultSGL, n, p, num=2, breaks=NULL)
SGLPlotChangePoint(resultSGL, n, p, num=3, breaks=NULL)
SGLPlotChangePoint(resultSGL, n, p, num=4, breaks=NULL)
SGLPlotChangePoint(resultSGL, n, p, num=5, breaks=NULL)
SGLPlotChangePoint(resultSGL, n, p, num=6, breaks=NULL)
SGLPlotChangePoint(resultSGL, n, p, num=7, breaks=NULL)
SGLPlotChangePoint(resultSGL, n, p, num=7, breaks=NULL)
SGLPlotChangePoint(resultSGL, n, p, num=6, breaks=NULL)
SGLPlotNorm(resultSGL, n, p, num=10, breaks=NULL,norm=2)
SGLPlotNorm <- function(fit, n, p, num=1, breaks=NULL,norm=2)
{
# this function plot the l1 norm of theta in the result
# num is the num th lambda we used
# n is the number of data sample
# p is the number of dimension
#norm=2 is l2 norm, norm=1 is l1 norm
#breaks is the break tick the user want to show on the plot,
#if breaks is NULL the default setting is to divide x-axis into 10 equal segment and label the
#tick accordingly
t_sum = matrix(NA, n, 1)
if(norm==1)
{
for (i in 1:n)
{ t_sum[i] = sum(abs(fit$beta[((i-1)*p+1):(i*p), num]))}
}
if(norm==2)
{
for (i in 1:n)
{ t_sum[i] = sqrt(sum((fit$beta[((i-1)*p+1):(i*p), num])^2))}
}
plotData <- data.frame(pos=1:length(t_sum), normL1=t_sum)
plotTsum <- ggplot(plotData, aes(pos, normL1))
{
if(is.null(breaks))
{
plotTsum + geom_point() + theme_bw(base_size=16) + xlab("Number of Observations") + ylab(expression(paste(group("|",group("|", theta[i], "|"),"|"))[1]))+scale_x_continuous(breaks=seq(1, n, floor(n/10)))
}
else
{
plotTsum + geom_point() + theme_bw(base_size=16) + xlab("Number of Observations") + ylab(expression(paste(group("|",group("|", theta[i], "|"),"|"))[1]))+scale_x_continuous(breaks=breaks)
}
}
#plotTsum + geom_point() + theme_bw(base_size=16) + xlab("Number of Observations") + ylab(expression(paste(group("|",group("|", theta[i], "|"),"|"))[1]))+scale_x_continuous(breaks=seq(1, n, floor(n/10)))
}
SGLPlotNorm(resultSGL, n, p, num=10, breaks=NULL,norm=2)
SGLPlotNorm(resultSGL, n, p, num=10, breaks=NULL,norm=1)
SGLPlotNorm <- function(fit, n, p, num=1, breaks=NULL,norm=2)
{
# this function plot the l1 norm of theta in the result
# num is the num th lambda we used
# n is the number of data sample
# p is the number of dimension
#norm=2 is l2 norm, norm=1 is l1 norm
#breaks is the break tick the user want to show on the plot,
#if breaks is NULL the default setting is to divide x-axis into 10 equal segment and label the
#tick accordingly
t_sum = matrix(NA, n, 1)
if(norm==1)
{
for (i in 1:n)
{ t_sum[i] = sum(abs(fit$beta[((i-1)*p+1):(i*p), num]*fit$X.transform))}
}
if(norm==2)
{
for (i in 1:n)
{ t_sum[i] = sqrt(sum((fit$beta[((i-1)*p+1):(i*p), num]*fit$X.transform)^2))}
}
plotData <- data.frame(pos=1:length(t_sum), normL1=t_sum)
plotTsum <- ggplot(plotData, aes(pos, normL1))
{
if(is.null(breaks))
{
plotTsum + geom_point() + theme_bw(base_size=16) + xlab("Number of Observations") + ylab(expression(paste(group("|",group("|", theta[i], "|"),"|"))[1]))+scale_x_continuous(breaks=seq(1, n, floor(n/10)))
}
else
{
plotTsum + geom_point() + theme_bw(base_size=16) + xlab("Number of Observations") + ylab(expression(paste(group("|",group("|", theta[i], "|"),"|"))[1]))+scale_x_continuous(breaks=breaks)
}
}
#plotTsum + geom_point() + theme_bw(base_size=16) + xlab("Number of Observations") + ylab(expression(paste(group("|",group("|", theta[i], "|"),"|"))[1]))+scale_x_continuous(breaks=seq(1, n, floor(n/10)))
}
SGLPlotNorm(resultSGL, n, p, num=10, breaks=NULL,norm=1)
SGLPlotNorm(resultSGL, n, p, num=10, breaks=NULL,norm=2)
SGLPlotNorm(resultSGL, n, p, num=10, breaks=NULL,norm=1)
SGLPlotNorm(resultSGL, n, p, num=5, breaks=NULL,norm=1)
SGLPlotNorm(resultSGL, n, p, num=6, breaks=NULL,norm=1)
SGLPlotNorm(resultSGL, n, p, num=7, breaks=NULL,norm=1)
SGLPlotNorm(resultSGL, n, p, num=8, breaks=NULL,norm=1)
SGLPlotNorm <- function(fit, n, p, num=1, breaks=NULL,norm=2)
{
# this function plot the l1 norm of theta in the result
# num is the num th lambda we used
# n is the number of data sample
# p is the number of dimension
#norm=2 is l2 norm, norm=1 is l1 norm
#breaks is the break tick the user want to show on the plot,
#if breaks is NULL the default setting is to divide x-axis into 10 equal segment and label the
#tick accordingly
t_sum = matrix(NA, n, 1)
if(norm==1)
{
for (i in 1:n)
{ t_sum[i] = sum(abs(fit$beta[((i-1)*p+1):(i*p), num]*fit$X.transform))}
}
if(norm==2)
{
for (i in 1:n)
{ t_sum[i] = sqrt(sum((fit$beta[((i-1)*p+1):(i*p), num]*fit$X.transform)^2))}
}
plotData <- data.frame(pos=1:length(t_sum), normL1=t_sum)
plotTsum <- ggplot(plotData, aes(pos, normL1))
if (norm==1)
{
if(is.null(breaks))
{
plotTsum + geom_point() + theme_bw(base_size=16) + xlab("Number of Observations") + ylab(expression(paste(group("|",group("|", theta[i], "|"),"|"))[1]))+scale_x_continuous(breaks=seq(1, n, floor(n/10)))
}
else
{
plotTsum + geom_point() + theme_bw(base_size=16) + xlab("Number of Observations") + ylab(expression(paste(group("|",group("|", theta[i], "|"),"|"))[1]))+scale_x_continuous(breaks=breaks)
}
}
if (norm==2)
{
if(is.null(breaks))
{
plotTsum + geom_point() + theme_bw(base_size=16) + xlab("Number of Observations") + ylab(expression(paste(group("|",group("|", theta[i], "|"),"|"))[2]))+scale_x_continuous(breaks=seq(1, n, floor(n/10)))
}
else
{
plotTsum + geom_point() + theme_bw(base_size=16) + xlab("Number of Observations") + ylab(expression(paste(group("|",group("|", theta[i], "|"),"|"))[2]))+scale_x_continuous(breaks=breaks)
}
}
#plotTsum + geom_point() + theme_bw(base_size=16) + xlab("Number of Observations") + ylab(expression(paste(group("|",group("|", theta[i], "|"),"|"))[1]))+scale_x_continuous(breaks=seq(1, n, floor(n/10)))
}
SGLPlotNorm(resultSGL, n, p, num=8, breaks=NULL,norm=2)
SGLPlotChangePoint <- function(fit, n, p, num=1, breaks=NULL)
{
# this function plot the l1 norm of theta in the result
# num is the num th lambda we used
# n is the number of data sample
# p is the number of dimension
#breaks is the break tick the user want to show on the plot,
#if breaks is NULL the default setting is to divide x-axis into 10 equal segment and label the
#tick accordingly
t_sum = mat.or.vec(n, 1)
for (i in 1:n)
{
if (sum(abs(fit$beta[((i-1)*p+1):(i*p),num]))>0)
{
t_sum[i]<-1
}
}
plotData <- data.frame(pos=1:length(t_sum), normL1=t_sum)
plotTsum <- ggplot(plotData, aes(pos, normL1))
{
if(is.null(breaks))
{
plotTsum + geom_point() + theme_bw(base_size=16) + xlab("Number of Observations") + ylab("Change-point")+scale_x_continuous(breaks=seq(1, n, floor(n/10)))+scale_y_continuous(breaks=c(0,1))
}
else
{
plotTsum + geom_point() + theme_bw(base_size=16) + xlab("Number of Observations") + ylab("Change-point")+scale_x_continuous(breaks=breaks)+scale_y_continuous(breaks=c(0,1))
}
}
retrun(t_sum)
}
SGLPlotNorm(resultSGL, n, p, num=8, breaks=NULL,norm=2)
t_sum <- SGLPlotNorm(resultSGL, n, p, num=8, breaks=NULL,norm=2)
SGLPlotNorm <- function(fit, n, p, num=1, breaks=NULL,norm=2)
{
# this function plot the l1 norm of theta in the result
# num is the num th lambda we used
# n is the number of data sample
# p is the number of dimension
#norm=2 is l2 norm, norm=1 is l1 norm
#breaks is the break tick the user want to show on the plot,
#if breaks is NULL the default setting is to divide x-axis into 10 equal segment and label the
#tick accordingly
t_sum = matrix(NA, n, 1)
if(norm==1)
{
for (i in 1:n)
{ t_sum[i] = sum(abs(fit$beta[((i-1)*p+1):(i*p), num]*fit$X.transform))}
}
if(norm==2)
{
for (i in 1:n)
{ t_sum[i] = sqrt(sum((fit$beta[((i-1)*p+1):(i*p), num]*fit$X.transform)^2))}
}
plotData <- data.frame(pos=1:length(t_sum), normL1=t_sum)
plotTsum <- ggplot(plotData, aes(pos, normL1))
if (norm==1)
{
if(is.null(breaks))
{
plotTsum + geom_point() + theme_bw(base_size=16) + xlab("Number of Observations") + ylab(expression(paste(group("|",group("|", theta[i], "|"),"|"))[1]))+scale_x_continuous(breaks=seq(1, n, floor(n/10)))
}
else
{
plotTsum + geom_point() + theme_bw(base_size=16) + xlab("Number of Observations") + ylab(expression(paste(group("|",group("|", theta[i], "|"),"|"))[1]))+scale_x_continuous(breaks=breaks)
}
}
if (norm==2)
{
if(is.null(breaks))
{
plotTsum + geom_point() + theme_bw(base_size=16) + xlab("Number of Observations") + ylab(expression(paste(group("|",group("|", theta[i], "|"),"|"))[2]))+scale_x_continuous(breaks=seq(1, n, floor(n/10)))
}
else
{
plotTsum + geom_point() + theme_bw(base_size=16) + xlab("Number of Observations") + ylab(expression(paste(group("|",group("|", theta[i], "|"),"|"))[2]))+scale_x_continuous(breaks=breaks)
}
}
#plotTsum + geom_point() + theme_bw(base_size=16) + xlab("Number of Observations") + ylab(expression(paste(group("|",group("|", theta[i], "|"),"|"))[1]))+scale_x_continuous(breaks=seq(1, n, floor(n/10)))
return(t_sum)
}
t_sum <- SGLPlotNorm(resultSGL, n, p, num=8, breaks=NULL,norm=2)
View(t_sum)
sqrt(160)
library(ChangePointCalc)
library(ChangePointCalc)
log(2)
log(3)
a=log(80000)/400
a
10*sqrt(a)
ChangePoints <- c(101,201)
n <- 400
p <- 200
s <- 10
SData <- SynthesizeData(ChangePoints, sigma1=1, sigma2=0.1, n, p, s,coefficients=NULL)
resultSGL <- SGLmain(data=SData,gamma=0.90)
SGLPlotChangePoint(resultSGL, n, p, num=20, breaks=NULL)
SGLPlotNorm(resultSGL, n, p, num=10, breaks=NULL,norm=2)
SGLPlotNorm(resultSGL, n, p, num=20, breaks=NULL,norm=2)
SGLPlotNorm(resultSGL, n, p, num=20, breaks=NULL,norm=2)
SGLPlotNorm(resultSGL, n, p, num=1, breaks=NULL,norm=2)
SGLPlotChangePoint(resultSGL, n, p, num=20, breaks=NULL)
SGLPlotNorm(resultSGL, n, p, num=20, breaks=NULL,norm=2)
SGLPlotNorm <- function(fit, n, p, num=1, breaks=NULL,norm=2)
{
# this function plot the l1 norm of theta in the result
# num is the num th lambda we used
# n is the number of data sample
# p is the number of dimension
#norm=2 is l2 norm, norm=1 is l1 norm
#breaks is the break tick the user want to show on the plot,
#if breaks is NULL the default setting is to divide x-axis into 10 equal segment and label the
#tick accordingly
t_sum = matrix(NA, n, 1)
if(norm==1)
{
for (i in 1:n)
{ t_sum[i] = sum(abs(fit$beta[((i-1)*p+1):(i*p), num]*fit$X.transform))}
}
if(norm==2)
{
for (i in 1:n)
{ t_sum[i] = sqrt(sum((fit$beta[((i-1)*p+1):(i*p), num]*fit$X.transform)^2))}
}
plotData <- data.frame(pos=1:length(t_sum), normL1=t_sum)
plotTsum <- ggplot(plotData, aes(pos, normL1))
if (norm==1)
{
if(is.null(breaks))
{
plotTsum + geom_point() + theme_bw(base_size=16) + xlab("Number of Observations") + ylab(expression(paste(group("|",group("|", theta[i], "|"),"|"))[1]))+scale_x_continuous(breaks=seq(1, n, floor(n/10)))
}
else
{
plotTsum + geom_point() + theme_bw(base_size=16) + xlab("Number of Observations") + ylab(expression(paste(group("|",group("|", theta[i], "|"),"|"))[1]))+scale_x_continuous(breaks=breaks)
}
}
if (norm==2)
{
if(is.null(breaks))
{
plotTsum + geom_point() + theme_bw(base_size=16) + xlab("Number of Observations") + ylab(expression(paste(group("|",group("|", theta[i], "|"),"|"))[2]))+scale_x_continuous(breaks=seq(1, n, floor(n/10)))
}
else
{
plotTsum + geom_point() + theme_bw(base_size=16) + xlab("Number of Observations") + ylab(expression(paste(group("|",group("|", theta[i], "|"),"|"))[2]))+scale_x_continuous(breaks=breaks)
}
}
#plotTsum + geom_point() + theme_bw(base_size=16) + xlab("Number of Observations") + ylab(expression(paste(group("|",group("|", theta[i], "|"),"|"))[1]))+scale_x_continuous(breaks=seq(1, n, floor(n/10)))
return(t_sum)
}
SGLPlotNorm(resultSGL, n, p, num=20, breaks=NULL,norm=2)
SGLPlotNorm <- function(fit, n, p, num=1, breaks=NULL,norm=2)
{
# this function plot the l1 norm of theta in the result
# num is the num th lambda we used
# n is the number of data sample
# p is the number of dimension
#norm=2 is l2 norm, norm=1 is l1 norm
#breaks is the break tick the user want to show on the plot,
#if breaks is NULL the default setting is to divide x-axis into 10 equal segment and label the
#tick accordingly
t_sum = matrix(NA, n, 1)
if(norm==1)
{
for (i in 1:n)
{ t_sum[i] = sum(abs(fit$beta[((i-1)*p+1):(i*p), num]*fit$X.transform))}
}
if(norm==2)
{
for (i in 1:n)
{ t_sum[i] = sqrt(sum((fit$beta[((i-1)*p+1):(i*p), num]*fit$X.transform)^2))}
}
plotData <- data.frame(pos=1:length(t_sum), normL1=t_sum)
plotTsum <- ggplot(plotData, aes(pos, normL1))
if (norm==1)
{
if(is.null(breaks))
{
plotTsum + geom_point() + theme_bw(base_size=16) + xlab("Number of Observations") + ylab(expression(paste(group("|",group("|", theta[i], "|"),"|"))[1]))+scale_x_continuous(breaks=seq(1, n, floor(n/10)))
}
else
{
plotTsum + geom_point() + theme_bw(base_size=16) + xlab("Number of Observations") + ylab(expression(paste(group("|",group("|", theta[i], "|"),"|"))[1]))+scale_x_continuous(breaks=breaks)
}
}
if (norm==2)
{
if(is.null(breaks))
{
plotTsum + geom_point() + theme_bw(base_size=16) + xlab("Number of Observations") + ylab(expression(paste(group("|",group("|", theta[i], "|"),"|"))[2]))+scale_x_continuous(breaks=seq(1, n, floor(n/10)))
}
else
{
plotTsum + geom_point() + theme_bw(base_size=16) + xlab("Number of Observations") + ylab(expression(paste(group("|",group("|", theta[i], "|"),"|"))[2]))+scale_x_continuous(breaks=breaks)
}
}
#plotTsum + geom_point() + theme_bw(base_size=16) + xlab("Number of Observations") + ylab(expression(paste(group("|",group("|", theta[i], "|"),"|"))[1]))+scale_x_continuous(breaks=seq(1, n, floor(n/10)))
}
SGLPlotNorm(resultSGL, n, p, num=20, breaks=NULL,norm=2)
library(ChangePointCalc)
library(ChangePointCalc)
ChangePoints <- c(101,301)
n <- 600
p <- 300
s <- 10
SData <- SynthesizeData(ChangePoints, sigma1=1, sigma2=0.1, n, p, s,coefficients=NULL)
resultSGL <- SGLmain(data=SData,gamma=0.90)
SGLPlotChangePoint(resultSGL, n, p, num=20, breaks=NULL)
SGLPlotNorm(resultSGL, n, p, num=20, breaks=NULL,norm=2)
library(ChangePointCalc)
ChangePoints <- c(101,301,701)
n <- 800
p <- 200
s <- 10
SData <- SynthesizeData(ChangePoints, sigma1=1, sigma2=0.1, n, p, s,coefficients=NULL)
resultSGL <- SGLmain(data=SData,gamma=0.90)
SGLPlotChangePoint(resultSGL, n, p, num=20, breaks=NULL)
SGLPlotNorm(resultSGL, n, p, num=20, breaks=NULL,norm=2)
SGLPlotNorm(resultSGL, n, p, num=20, breaks=1:100:801,norm=2)
1:100:801
seq(1,801, by=100
)
SGLPlotNorm(resultSGL, n, p, num=20, breaks=seq(1,801, by=100),norm=2)
save.image("C:/Users/bzhang/Dropbox/SGL program/PackageTest_11_26_2014/ChangePointCalc/high_SGL_04282015.RData")
SGLPlotChangePoint(resultSGL, n, p, num=20, breaks=seq(1,801, by=100),norm=2)
SGLPlotChangePoint(resultSGL, n, p, num=20, breaks=seq(1,801, by=100))
